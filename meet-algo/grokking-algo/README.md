图解算法
-------


### 大O表示法

大O表示法是一种特殊的表示法，指出了算法在最糟情况下随输入的增加运行时间以什么样的速度增加（除了最糟情况下的运行时间之外，还应考虑平均情况下的运行时间）。常见的大O运行时间有：
* `O(logN)`；也叫对数时间，如二分查找
* `O(N)`：也叫线性时间，如简单查找
* `O(NlogN)`：如快速排序算法
* `O(N^2)`：如选择排序算法
* `O(N!)`：埋了吧

算法的的速度指的并非时间，而是操作数的增速（随着输入的增加，运行时间将会以什么样的速度增加）。


### 二分查找

二分查找是一种算法，其输入是一个**有序**的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回NULL。

一般而言，对于包含N个元素的列表，用二分查找最多需要log<sub>2</sub>n步，而简单查找最多需要n步。


### 递归

在递归问题首先要解决如何将问题分为基线条件和递归条件：
 * 基线条件：指函数不再调用自己，避免形成死循环
 * 递归条件：指函数需要再次调用自己

使用栈的代价：存储详尽的信息在栈中需要占用大量的内存。每个函数调用都要占用一定的内存。如果栈很高，就意味着计算机存储了大量函数调用的信息。


### 分治算法

分治算法（Divide and conquer, D&C）是一种通用的问题解决方法。使用D&C解决问题的过程包括两个步骤：
 1. 找出基线条件，这种条件必须尽可能简单。
 2. 不断将问题分析（或者说缩小规模），直到符合基线条件。

快速排序是一种常用的排序算法，比选择排序快得多。快速排序的工作流程：
 1. 从数组中选择一个元素，这个元素的值被称为基准值（Pivot）
 2. 找出比基准值小的元素以及比基准值大的元素（这被称为分区（Partitioning））
 3. 对这两个子数组进行快速排序，再合并结果就能得到一个有序数组

快速排序的性能高度依赖于所选择的基准值。在最糟情况下，快速排序算法将会退化到O(N^2)复杂度，而在平均情况下将是O(NlonN)的复杂度。


### 散列表

散列函数：将输入映射到数字，并且散列函数需要满足一定的要求：
 * 必须是一致的，即相同的输入都能得到相同的输出
 * 应该将不同的输入映射到不同的数字上（需要能做到均匀映射）

与数组和链表访问内存的区别：数组和链表都是被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。

散列函数对不同的输入得到了相同的输出的这种情况称之为冲突（Collision）。冲突很糟糕，必须要避免。处理冲突的方式有很多，最简单的办法是：如果两个键映射到了同一个位置，就在这个地方存储一个链表。
 * 散列函数很重要。最理想的情况是散列函数将键均匀地映射到散列表的不同位置。
 * 如果散列表存储的链表很长，散列表的速度将急剧下降

在平均情况下，散列表的查找和数组一样快，而插入和删除速度与链表一样快，因此散列表兼具数组和链表的优点。但是在最糟情况下将会退化到O(N)复杂度下。避免冲突需要的有：
 * 较低的填装因子（包含的元素数 / 位置总数）
 * 良好的散列函数

填装因子大于1意味着散列表中存储的元素数量已经超过了数组的位置数。一旦填装因子开始增大，就需要在散列表中添加位置，这被称为调整长度（Resizing）。装填因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。


### 广度优先搜索

图由节点和边组成，一个节点可能与众多节点直接相连，这些节点被称为邻居。在图中如果边为箭头，箭头的方向指定了关系的导向，这被称之为有向图。而无向图中的边不带箭头，其中的关系时双向的。

广度优先搜索可以回答图的两类问题：
 * 从节点A出发，有前往节点B的路径吗？
 * 从节点A出发，前往节点B的哪条路径最短？

在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，先检查起点的邻居，在检查邻居的邻居。在搜索过程中必须按照添加顺序进行检查，所以这就会使用到“队列”这种数据结构。

#### 队列

队列类似于栈，同样也不能访问队列中的元素。队列只支持两种操作：入队和出队。队列是一种先进先出（First In First Out, FIFO）的数据结构，而栈是一种后进先出（Last In First Out）的数据结构。

对于检查过的节点，务必不要再次去检查，否则可能导致无限循环。


### 迪克斯特拉算法

在图中，使用广度优先搜索将从点A到点B边最少的路径，而为了找出从点A到点B耗时（权重）最短的路径，将使用迪克斯特拉算法。迪克斯特拉算法包含4个步骤：
 1. 找出最便宜的“节点”，即可在最短时间内到达的节点
 2. 更新该节点的邻居的开销
 3. 重复这个过程，直到对图中的每个点都这样做了
 4. 计算最终路径

在迪克斯特拉算法用于每条边都包含关联数字的图，这些数字被称为权重（weight）。带权重的图被称之为加权图，不带权重的图被称之为非加权图。要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用迪克斯特拉算法。**在无向图中，每条边都是一个环，迪克斯特拉算法只适用于加权无环图。**

迪克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径。也真是因为这个思想，在处理过一个节点之后就意味着没有前往该节点的更便宜路径，但是在存在负权边的情况下将会出现更便宜的路径。所以不能将迪克斯特拉算法用于包含负权边的图。如果需要在包含负权边的图中找到最短路径，可使用另一种算法——贝尔曼-福德算法（Bellman-Ford algorithm）。


### 贪婪算法

避免在NP完全问题上浪费时间去寻找快速的解决办法。针对这类问题可以使用近似算法，以快速找到NP完全问题的近似解——贪婪策略。

贪婪算法很简单：每步都采取最优的做法，即每次的选择都是局部最优解，最终得到的就是全局最优解。所以贪婪算法的优点就是简单易行。

在有些情况下，完美是优秀的敌人。有时候，如果只需要找到一个能够大致解决问题的算法，这是贪婪算法正好可派上用场，因为贪婪算法实现起来很容易，得到的结果又与正确结果相当接近。

贪婪算法只是一种近似算法（Approximation algorithm），在获取精确答案需要的时间太长时，可使用近似算法。衡量近似算法优劣的标准有：
 * 速度有多快
 * 得到的近似解与最优解的接近程度

#### NP完全问题

NP完全问题的的简单定义是，以难解著称的问题，比如旅行商问题和集合覆盖问题。旅行商问题和集合覆盖问题有一些共同之处：需要计算所有的解，并从中选出最小/最短的那个。

如何判断NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。但还是有一些蛛丝马迹可循的：
 * 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
 * 涉及“所有组合”的问题通常是NP完全问题
 * 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题
 * 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决。这可能是NP完全问题
 * 如果问题涉及集合（如广播台集合）且难以解决。这可能是NP完全问题
 * 如果问题可转换为集合覆盖问题或旅行商问题，那它可能是NP完全问题


### 动态规划

动态规划先解决之问题，再逐步解决大问题。这里所解决的小问题将帮助你解决大问题。每个动态规划算法都是从一个网格开始的，网格中的值通常就是需要进行优化的值。每个单元格都是一个子问题，因此应考虑如何将问题分成子问题，这有助于找出网格的坐标轴。

动态规划可在给定约束条件下找到最优解（在给定约束条件下优化某种指标），当且仅当每个子问题是离散的，即不依赖于其他子问题（子问题不会因为先处理或后处理而改变）时，动态规划才管用（如果存在疑虑情况，或者子问题是连续的，可选择使用贪婪算法）。

__没有放之四海而皆准的计算动态规划解决方案的公式。必须通过尝试才能找出管用的公式。__

一些实例：
 * 背包问题
 * 最长公共子串
 * 最长公共子序列
 * git diff找出两个文件的差异
 * 编辑距离指出两个字符串的相似程度：拼写检查、判断上传的资料是否是盗版
 * Word中的断字功能：确定在什么地方断字确保行长一致


### KNN（K-Nearest Neighbours）最近邻算法

KNN算法虽然简单却很有用！要对东西进行分类时，可首先尝试这种算法。

KNN算法可以用来做两项基本工作：
 * 分类：分类就是编组
 * 回归：回归就是预测结果

使用KNN算法时，挑选合适的特征进行比较至关重要。所谓合适的特征是：
 * 与要所要分类的事务紧密相关的特征
 * 不偏不倚的特征（特征的适用范围要覆盖全面）

在KNN算法中药计算两点之间的距离（相似程度）可使用毕达哥拉斯公式（`sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2 + (z1 - z2) ^ 2 + ...)`）

虽然可以使用距离公式来计算两个事物的相似程度。但是在实际工作中经常使用余弦相似度（Cosine similarity）。余弦相似度不计算两个矢量的距离，而是比较它们的角度。


### 更多

* 二分查找树（BST, Binary Search Tree）
    * B树, 红黑树, 堆, 伸展树

* 搜索引擎
    * 反向索引：在一个散列表中保存单词到单词所在页面的映射。

* 傅里叶变换：
    * [Better Explained](https://betterexplained.com/)
    * 傅里叶变换非常适合用于处理信号，可使用它来亚索音乐
    
* 并行算法（海量数据处理）
    * MapReduce：MapReduce是一种流行的分布式算法，可以通过开源根据Apache Hadoop来使用它。
        * MapReduce基于两个非常简单的理念：映射（Map）和归并（Reduce）
            * 映射：接受一个数组，并对其中每个元素进行相同的操作（这些操作放到不同的机器上去执行）
            * 归并：将一个数组转换为一个元素
    * 布隆过滤器和HyperLogLog
        * 布隆过滤器：布隆过滤器是一种概率型数据结构，它提供的答案可能对也可能不对，但很可能是正确的
            * 优点是占用空间极小，非常适用于不要求答案绝对准确的情况
        * HyperLogLog：HyperLogLog是一种类似于布隆过滤器的算法，用于近似统计某个键发生的次数

* SHA算法（Secure Hash Algorithm，安全散列算法）
    * 判断两个文件是否相同，这在比较超大型文件时很有用
    * 检查密码，可在数据库中保存原始密码的散列值，并在之后用于比较
    * SHA算法是局部不敏感的散列算法（修改部分将会导致结果截然不同），但有时候需要局部敏感的散列算法可使用Simhash

* Diffie-Hellman秘钥交换
    * 解决一个古老的问题：如何对消息进行加密，以便只有收件人才能看懂。

