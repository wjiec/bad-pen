图解算法
-------


### 大O表示法

大O表示法是一种特殊的表示法，指出了算法在最糟情况下随输入的增加运行时间以什么样的速度增加（除了最糟情况下的运行时间之外，还应考虑平均情况下的运行时间）。常见的大O运行时间有：
* `O(logN)`；也叫对数时间，如二分查找
* `O(N)`：也叫线性时间，如简单查找
* `O(NlogN)`：如快速排序算法
* `O(N^2)`：如选择排序算法
* `O(N!)`：埋了吧

算法的的速度指的并非时间，而是操作数的增速（随着输入的增加，运行时间将会以什么样的速度增加）。


### 二分查找

二分查找是一种算法，其输入是一个**有序**的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回NULL。

一般而言，对于包含N个元素的列表，用二分查找最多需要log<sub>2</sub>n步，而简单查找最多需要n步。


### 递归

在递归问题首先要解决如何将问题分为基线条件和递归条件：
 * 基线条件：指函数不再调用自己，避免形成死循环
 * 递归条件：指函数需要再次调用自己

使用栈的代价：存储详尽的信息在栈中需要占用大量的内存。每个函数调用都要占用一定的内存。如果栈很高，就意味着计算机存储了大量函数调用的信息。


### 分治算法

分治算法（Divide and conquer, D&C）是一种通用的问题解决方法。使用D&C解决问题的过程包括两个步骤：
 1. 找出基线条件，这种条件必须尽可能简单。
 2. 不断将问题分析（或者说缩小规模），直到符合基线条件。

快速排序是一种常用的排序算法，比选择排序快得多。快速排序的工作流程：
 1. 从数组中选择一个元素，这个元素的值被称为基准值（Pivot）
 2. 找出比基准值小的元素以及比基准值大的元素（这被称为分区（Partitioning））
 3. 对这两个子数组进行快速排序，再合并结果就能得到一个有序数组

快速排序的性能高度依赖于所选择的基准值。在最糟情况下，快速排序算法将会退化到O(N^2)复杂度，而在平均情况下将是O(NlonN)的复杂度。


### 散列表

散列函数：将输入映射到数字，并且散列函数需要满足一定的要求：
 * 必须是一致的，即相同的输入都能得到相同的输出
 * 应该将不同的输入映射到不同的数字上（需要能做到均匀映射）

与数组和链表访问内存的区别：数组和链表都是被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。

散列函数对不同的输入得到了相同的输出的这种情况称之为冲突（Collision）。冲突很糟糕，必须要避免。处理冲突的方式有很多，最简单的办法是：如果两个键映射到了同一个位置，就在这个地方存储一个链表。
 * 散列函数很重要。最理想的情况是散列函数将键均匀地映射到散列表的不同位置。
 * 如果散列表存储的链表很长，散列表的速度将急剧下降

在平均情况下，散列表的查找和数组一样快，而插入和删除速度与链表一样快，因此散列表兼具数组和链表的优点。但是在最糟情况下将会退化到O(N)复杂度下。避免冲突需要的有：
 * 较低的填装因子（包含的元素数 / 位置总数）
 * 良好的散列函数

填装因子大于1意味着散列表中存储的元素数量已经超过了数组的位置数。一旦填装因子开始增大，就需要在散列表中添加位置，这被称为调整长度（Resizing）。装填因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。


### 广度优先搜索

图由节点和边组成，一个节点可能与众多节点直接相连，这些节点被称为邻居。在图中如果边为箭头，箭头的方向指定了关系的导向，这被称之为有向图。而无向图中的边不带箭头，其中的关系时双向的。

广度优先搜索可以回答图的两类问题：
 * 从节点A出发，有前往节点B的路径吗？
 * 从节点A出发，前往节点B的哪条路径最短？

在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，先检查起点的邻居，在检查邻居的邻居。在搜索过程中必须按照添加顺序进行检查，所以这就会使用到“队列”这种数据结构。

#### 队列

队列类似于栈，同样也不能访问队列中的元素。队列只支持两种操作：入队和出队。队列是一种先进先出（First In First Out, FIFO）的数据结构，而栈是一种后进先出（Last In First Out）的数据结构。

对于检查过的节点，务必不要再次去检查，否则可能导致无限循环。


### 迪克斯特拉算法
