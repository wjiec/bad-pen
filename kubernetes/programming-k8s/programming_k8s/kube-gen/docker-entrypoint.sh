#!/usr/bin/env bash

set -o errexit
set -o pipefail

# The header file to insert into generated files.
BOILERPLATE=""

# The root package under which to search for files which request code to be generated.
PACKAGE_ROOT=""

# The script will only display the commands to be executed without actually executing them.
DRY_RUN=""

# The basename of the generated package.
OUTPUT_PACKAGE="generated"

# The name of the generated clientset package.
CLIENTSET_NAME="clientset"

# The version of the generated clientset package.
VERSIONED_NAME="versioned"

# Determines how much log output these generator generate.
KUBE_VERBOSE="${KUBE_VERBOSE:-0}"

# Defines the root of Go workspace.
GOPATH="${GOPATH:-$(go env GOPATH)}"

while [ "$#" -gt 0 ]; do
  case "$1" in
    "--boilerplate")
      BOILERPLATE="$2"
      shift 2
      ;;
    "--pkg-root")
      PACKAGE_ROOT="$2"
      shift 2
      ;;
    "--dry-run")
      DRY_RUN="echo"
      shift 1
      ;;
    "--clientset-name")
      CLIENTSET_NAME="$2"
      shift 2
      ;;
    "--versioned-name")
      VERSIONED_NAME="$2"
      shift 2
      ;;
    *)
      echo "unknown argument: $1" >&2
      exit 1
      ;;
  esac
done

if [[ -z $BOILERPLATE ]]; then
  BOILERPLATE="${GOPATH}/src/$(dirname "${PACKAGE_ROOT}")/hack/boilerplate.go.txt"
  if [[ ! -f "$BOILERPLATE" ]]; then
    BOILERPLATE="/hack/boilerplate.go.txt"
  fi
fi

[[ -n "${KUBE_DEBUG:-}" ]] && set -o xtrace

# args: [pkg-root] [regexp]
function kube::codegen::internal::grep_find() {
  pattern=$(kube::codegen::internal::generated_pattern '\w+-gen')
  if [[ $pattern == "$2" ]]; then
    find "${GOPATH}/src/$1" -name "*.go" -print0 | xargs -0 grep -l "$2"
  else
    find "${GOPATH}/src/$1" -name "*.go" -print0 | xargs -0 grep -E -L "${pattern}" | xargs grep -l "$2"
  fi
}

# args [version]
function kube::codegen::internal::is_version() {
  echo "$1" | grep -E -q '^v[0-9]+((alpha|beta)[0-9]+)?$'
}

# args [gen]
function kube::codegen::internal::generated_pattern() {
  echo "^// Code generated by $1." 'DO NOT EDIT.$'
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::find_pkg() {
  local pkgs=()
  for source in $(kube::codegen::internal::grep_find "$1" "$2"); do
    pkgs+=("$(cd "$(dirname "$source")" && GO111MODULE=on go list -find .)")
  done

  echo "${pkgs[@]}" | xargs -n1 | sort -u | tr '\n' ' '
}

# args: [pkg-root]
function kube::codegen::internal::download_mod() {
    cd "${GOPATH}/src/$1" && go mod download
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::remove_match() {
  for source in $(kube::codegen::internal::grep_find "$1" "$2"); do
    rm -rf "$source"
  done
}

# args: [pkg-root] [gen]
function kube::codegen::internal::remove_generated() {
  kube::codegen::internal::remove_match "$1" "$(kube::codegen::internal::generated_pattern "$2")"
  find "${GOPATH}/src/$1" -type d -empty -delete
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::apis_base() {
  local gen_pkgs; local apis_pkg; local version

  gen_pkgs=$(kube::codegen::internal::find_pkg "$1" "$2")
  for gen_pkg in $gen_pkgs; do
    version=$(basename "${gen_pkg}")
    if kube::codegen::internal::is_version "${version}"; then
      apis_pkg=$(dirname "$(dirname "${gen_pkg}")")
    fi
  done

  echo "$apis_pkg"
}

# args: [pkg-root] [regexp]
function kube::codegen:internal::inputs() {
    local gen_pkgs

    IFS=" " read -r -a gen_pkgs <<< "$(kube::codegen::internal::find_pkg "$1" "$2")"
    if [[ "${#gen_pkgs[@]}" != 0 ]]; then
      local inputs=()
      for gen_pkg in "${gen_pkgs[@]}"; do
        inputs+=("--input-dirs=${gen_pkg}")
      done
      echo "${inputs[@]}"
    fi
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::gv_inputs() {
  local gen_pkgs

  IFS=" " read -r -a gen_pkgs <<< "$(kube::codegen::internal::find_pkg "$1" "$2")"
  if [[ "${#gen_pkgs[@]}" != 0 ]]; then
    local gv_inputs=()
    for gen_pkg in "${gen_pkgs[@]}"; do
      local group; local version
      version=$(basename "${gen_pkg}")
      if kube::codegen::internal::is_version "${version}"; then
        group=$(basename "$(dirname "${gen_pkg}")")
        gv_inputs+=("--input=${group}/${version}")
      fi
    done

    echo "${gv_inputs[@]}" | xargs -n1 | sort -u | tr '\n' ' '
  fi
}

# args: [gen] [file_base] [pkg-root] [regexp]
function kube::codegen::internal::gen_helper() {
  local gen_inputs

  IFS=" " read -r -a gen_inputs <<< "$(kube::codegen:internal::inputs "$3" "$4")"
  if [[ "${#gen_inputs[@]}" != 0 ]]; then
    echo "Generating $(echo "$1" | cut -d'-' -f1) code for ${#gen_inputs[@]} targets"
    ${DRY_RUN} "$1" -v "$KUBE_VERBOSE" \
      --go-header-file="$BOILERPLATE" \
      --output-file-base="$2" \
      --output-base="${GOPATH}/src" \
      "${gen_inputs[@]}"
  fi
}

# args: [pkg-root]
function kube::codegen::helpers() {
  kube::codegen::internal::gen_helper "deepcopy-gen" "zz_generated.deepcopy" "$1" "+k8s:deepcopy-gen="
  kube::codegen::internal::gen_helper "register-gen" "zz_generated.register" "$1" "+k8s:deepcopy-gen="
  kube::codegen::internal::gen_helper "defaulter-gen" "zz_generated.defaults" "$1" "+k8s:defaulter-gen="
  kube::codegen::internal::gen_helper "conversion-gen" "zz_generated.conversion" "$1" "+k8s:conversion-gen="
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::gen_applyconfiguration() {
  local gen_inputs

  IFS=" " read -r -a gen_inputs <<< "$(kube::codegen:internal::inputs "$1" "$2")"
  if [[ "${#gen_inputs[@]}" != 0 ]]; then
    echo "Generating applyconfiguration code for ${#gen_inputs[@]} targets"
    ${DRY_RUN} applyconfiguration-gen -v "$KUBE_VERBOSE" \
      --go-header-file="$BOILERPLATE" \
      --output-base="${GOPATH}/src" \
      --output-package="$1/${OUTPUT_PACKAGE}/applyconfiguration" \
      "${gen_inputs[@]}"
  fi
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::gen_client() {
  local gv_inputs

  IFS=" " read -r -a gv_inputs <<< "$(kube::codegen::internal::gv_inputs "$1" "$2")"
  if [[ "${#gv_inputs[@]}" != 0 ]]; then
    echo "Generating client code for ${#gv_inputs[@]} targets"
    ${DRY_RUN} client-gen -v "$KUBE_VERBOSE" \
      --go-header-file="$BOILERPLATE" \
      --clientset-name="$VERSIONED_NAME" \
      --input-base="$(kube::codegen::internal::apis_base "$1" "$2")" \
      --output-base="${GOPATH}/src" \
      --output-package="$1/${OUTPUT_PACKAGE}/${CLIENTSET_NAME}" \
      --apply-configuration-package="$1/${OUTPUT_PACKAGE}/applyconfiguration" \
      "${gv_inputs[@]}"
  fi
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::gen_lister() {
  local gen_inputs

  IFS=" " read -r -a gen_inputs <<< "$(kube::codegen:internal::inputs "$1" "$2")"
  if [[ "${#gen_inputs[@]}" != 0 ]]; then
    echo "Generating lister code for ${#gen_inputs[@]} targets"
    ${DRY_RUN} lister-gen -v "$KUBE_VERBOSE" \
      --go-header-file="$BOILERPLATE" \
      --output-base="${GOPATH}/src" \
      --output-package="$1/${OUTPUT_PACKAGE}/listers" \
      "${gen_inputs[@]}"
  fi
}

# args: [pkg-root] [regexp]
function kube::codegen::internal::gen_informer() {
  local gen_inputs

  IFS=" " read -r -a gen_inputs <<< "$(kube::codegen:internal::inputs "$1" "$2")"
  if [[ "${#gen_inputs[@]}" != 0 ]]; then
    echo "Generating informer code for ${#gen_inputs[@]} targets"
    ${DRY_RUN} informer-gen -v "$KUBE_VERBOSE" \
      --go-header-file="$BOILERPLATE" \
      --output-base="${GOPATH}/src" \
      --output-package="$1/${OUTPUT_PACKAGE}/informers" \
      --versioned-clientset-package="$1/${OUTPUT_PACKAGE}/${CLIENTSET_NAME}/${VERSIONED_NAME}" \
      --listers-package="$1/${OUTPUT_PACKAGE}/listers" \
      "${gen_inputs[@]}"
  fi
}

# args: [pkg-root]
function kube::codegen::client() {
  kube::codegen::internal::gen_applyconfiguration "$1" "+genclient"
  kube::codegen::internal::gen_client "$1" "+genclient"
  kube::codegen::internal::gen_lister "$1" "+genclient"
  kube::codegen::internal::gen_informer "$1" "+genclient"
}

# args: [pkg-root]
function kube::codegen::all() {
  kube::codegen::internal::download_mod "$1"
  kube::codegen::internal::remove_generated "$1" '\w+-gen'

  kube::codegen::helpers "$1"
  kube::codegen::client "$1"
}

kube::codegen::all "$PACKAGE_ROOT"
