Kubernetes介绍
-----------------------

如今，大型单体应用正被逐渐分解成小的、可独立运行的组件（我们称之为**微服务**）。微服务彼此之间解耦，所以它们可以被独立开发、部署、升级、伸缩。这使得我们可以对每一个微服务实现快速迭代，并且迭代的速度可以和市场需求的变化相匹配。

随着部署组件的增加和数据中心的增长，配置和管理并保持系统的正常运行变得越来越困难。我们想降低硬件成本并获得足够高的资源利用率正变得越来越困难。

而这正是Kubernetes在做的，Kubernetes可以进行自动化的调度、配置、监管和故障处理。Kubernetes使开发者能完全脱离运维团队的帮助自主部署应用，并且控制部署的频率。而运维团队可以通过Kubernetes监控整个系统，并且在硬件故障时重新调度应用。

Kubernetes通过对实际硬件做抽象，然后将自身暴露成一个平台用于部署和运行应用程序。它允许开发者自己配置和部署应用程序，而不需要系统管理员的任何帮助。让系统管理员聚焦于保持底层基础设施运转正常的同时，不需要关注实际运行在平台的应用程序。

### Kubernetes系统的需求

Kubernetes一方面需要适应因为应用部署的变化而出现的环境需求的差异，另一方面是需要适应应用的基础架构（环境和依赖）的变化。

#### 应用开发部署的变化

对于单体应用来说，即使是某个组件中小的修改，都需要重新部署整个应用。组件之间缺乏严格的边界定义，组件之间相互依赖。日积月累下来导致系统复杂度提升，整体质量也急剧恶化。

这些问题迫使我们将复杂的大型单体应用拆分为小的可独立部署的微服务组件。每个微服务以独立的进程运行，并通过**简单且定义良好**的接口与其他服务通信。

##### 单体应用和微服务应用的扩容对比

因为每个微服务都是独立的进程，只要API不变或者保持向前兼容，那么我们并不需要对其他微服务进行改动或者重新部署。

面向单体系统，扩容针对的是整个系统。而对于微服务架构，扩容只需要针对单个服务，这意味着我们可以选择性的扩容需要更多资源微服务，而其他微服务了仍然保持原样。

##### 部署微服务

微服务在组件数量增多的时候，也暴露了一些缺点，部署相关的决定会变得越来越困难（应用的组合变多，应用间依赖的组合更以几何倍数变多）。

##### 环境需求的差异

因为微服务架构中的组件不仅是独立部署，也是在独立开发。正是因为这种独立性，不同的组件使用不同的环境和依赖是非常常见的事情。在生产服务器部署并管理这种应用简直就是运维的噩梦。

#### 为应用程序提供一个一致的环境

开发和运维团队需要解决的最大的一个问题是程序运行环境的差异性，这种差异性存在于从硬件到操作系统再到没太机器的动态链接库上。为了解决这个问题，最理想的做法是让应用在开发和生产环境运行在完全一样的环境下（一样的操作系统、动态库、系统配置、网络环境和其他所有的条件）。

#### 持续交付：DevOps

让一个团队参与应用的开发、部署、运维的整个生命周期可以让开发者、QA和运维团队彼此之间的合作贯穿整个流程。这种实践被称为DevOps。

##### 带来的优点

这种实践可以让开发者更多地在生产环境中运行应用，并更多的理解用户的需求和问题，以及运维团队维护应用所面临的困难。

##### 让开发者和系统管理员做他们最擅长的

让开发者创造性的功能和提升用户体验，让运维团队负责管理生产部署流程以及应用所在的硬件设备。

### 容器技术

Kubernetes使用Linux容器技术来隔离应用，通过熟悉容器的基本知识来更加深入地理解Kubernetes，包括认识到存在得容器技术分支（例如Docker或者rkt）。

#### 什么是容器

当一个应用程序的组件开始变小且数量开始增长时，如果不想因为创建过多的虚拟机浪费硬件资源，又想持续压低硬件成本，那就不能给每个组件配置一个虚拟机了。而这不仅仅是浪费硬件资源的问题，因为每个虚拟机需要背单独配置和管理，所以增加虚拟机的数量也会带来人力资源的浪费。

##### 用Linux容器技术隔离组件

容器允许在一台机器上运行多个服务，不仅为不同的服务提供不同的环境，同时也会将这些服务相互隔离。**容器类似于虚拟机，但是开销小得多**。

**容器中运行的进程实际上运行在宿主机的操作系统上**，就像所有其他进程一样（虚拟机中的进程是运行在不同操作系统上的），但是容器中的进程是和其他进程隔离的。

##### 比较虚拟机和容器

与虚拟机相比，**容器更加轻量化**（它允许在相同的硬件上运行更多的服务）。虚拟机需要运行自己的一组系统进程，这些系统进程就会产生额外的计算资源消耗，而多个容器则会完全在宿主机的内核上运行。

虚拟机的主要好处是他们提供**完全隔离的环境**，因为每个虚拟机都运行在它自己的内核上，而**容器都是调用的同一个内核**（这也会带来一定的安全隐患）。

##### 容器实现隔离的机制

容器实现隔离主要依赖于以下2个功能：

* Linux的**命名空间**：它使每个进程只能看到它自己所在的命名空间的系统资源（文件、进程、网络接口、主机名等）
* Linux**控制组**（cgroup）：它限制了进程能使用的资源量（CPU、内存、网络带宽等）

##### 命名空间隔离的系统资源

运行在某个命名空间中的进程将只能看到同一个命名空间下的资源。系统存在多个类型的多个命名空间，所以**进程不单单只属于某一个命名空间，而是属于每个类型下的某一个命名空间**。存在以下类型的命名空间：

* Mount（mnt）
* Process ID（pid）
* Network（net）
* Inter-Process Communication（ipc）
* UTS（hostname、domain）
* User ID（user）

以上每种命名空间被用来隔离一组特定的资源。

##### 限制进程的可用资源

cgroup是一个Linux内核功能，它被用来**限制一个进程或者一组进程的资源使用**，这种限制使得进程不能过分使用为其他进程保留的资源。

#### Docker容器平台介绍

**Docker是第一个使容器能在不同机器之间移植的系统**，容器技术也是因为Docker的出现而变得广为人知。

基于Docker容器的镜像和虚拟机的镜像一个很大的不同是**容器镜像是多层结构**的，每个层能在多个镜像之间共享。

##### Docker的概念

**Docker是一个打包、分发和运行应用程序的平台**，它允许你将应用程序和应用程序所依赖的整个环境打包在一起，并且Docker通过中央仓库使得这个包可以被分发到任何运行Docker的机器上并被执行。而这依赖于一下三个主要概念：

* 镜像：Docker镜像里包含了打包的应用程序及其所依赖的环境
* 镜像仓库：用于存放Docker镜像，促进不同人和不同电脑之间共享这些镜像
* 容器：基于Docker镜像创建的Linux容器，在其中运行的应用程序与宿主机上的其他镜像相互隔离并且资源受限

##### 镜像层（Layer）

**不同镜像可能包含完全相同的层**，因为这些镜像可能都是在另一个镜像之上构建的（不同的镜像都能使用相同的父镜像作为它们的基础镜像）

**镜像层不仅使分发变得更加高效，也有助于减少镜像的存储空间**（相同的层会被共享，镜像层是只读的）。

##### 容器镜像移植上的限制

如果一个容器化的应用需要一个特定的内核版本，那它可能就会有移植上的问题（不能在所有机器上都正常工作）。而不仅仅是内核的问题，在一个特定硬件架构（amd64、arm）之上编译出来的容器应用只能在相同架构的机器上运行。

#### rkt（一个Docker的替代方案）

和Docker一样，rkt也是一个运行容器的平台，它更强调安全性、可构建性，并遵从容器开放标准（OCI）。

**不应该错误的认为Kubernetes只是一个专门为Docker容器设计的容器编排系统。实际上Kubernetes的核心远不止是容器编排**

### Kubernetes介绍

随着系统可部署组件的数量增长，**需要一个更好的方式来部署和管理这些组件**，并**支持基础设施的全球性伸缩**。除了**简化开发和管理**，我们也需要它能**获得更高的基础设施利用率**。

#### 深入浅出Kubernetes

**Kubernetes是一个软件系统**，它允许你在其上很容易地部署和管理容器化的应用。**Kubernetes将底层基础设施抽象，简化了应用的开发、部署以及对开发和运维团队的管理**。

##### Kubernetes的核心功能

Kubernetes将开发者提交上来的一个**应用列表中的组件**部署到**集群的工作节点**上。

##### 帮助开发者聚焦核心应用功能

Kubernetes可以被当做一个集群的操作系统，它实现了一些和基础设施相关的服务，包括**服务发现、扩容、负载均衡、自恢复**等。应用开发者因此能集中精力实现应用本身的功能而不用浪费时间思索怎样集成应用和基础设施。

##### 帮助运维团队获取更高的资源利用率

Kubernetes将你的容器化应用运行在集群的某个地方，并能在任何时间迁移应用通过混合和匹配应用来**获得比手动调度高很多的资源利用率**。

#### Kubernetes集群架构

在硬件级别上，Kubernetes集群由很多节点组成，这些节点被分成以下两种类型：

* **主节点**：承载Kubernetes控制和管理整个集群系统的控制面板
* **工作节点**：运行用户实际部署的应用

##### 控制面板

**控制面板用于控制集群并使集群能正常工作**。它包含多个组件，组件可以运行在单个节点上或者通过副本分别部署在多个主节点以确保高可用性。

* **ApiServer**：提供各个组件通信接口
* **Scheduler**：调度应用程序到某个工作节点
* **Controller Manager**：执行集群级别的功能（节点管理、持续跟踪节点、处理失败节点等）
* **etcd**：持久化存储集群的配置信息

##### 工作节点

**工作节点是运行容器化应用的机器**。运行、监控和管理应用程序的任务是由以下组件完成的：

* **Docker、rkt**：用于运行应用程序
* **kubelet**：与ApiServer进行通信，并管理所在节点的容器
* **kube-proxy**：负责处理组件之间的网络流量，提供负载均衡等

##### 附加组件

* kubedns：用于在集群内提供基于服务名字的解析服务
* ingress-controller：用于提供基于http(s)的主机/路由映射支持
* 容器网络接口插件（CNI）：用于建立集群内部的扁平网络
* Dashboard：用于监控和可视化操作Kubernetes

#### 在Kubernetes中运行应用

为了在Kubernetes中运行应用，首先需要**将应用打包进一个或多个容器镜像**，再将这些容器镜像**推送到容器仓库中**，最后**将应用程序的Spec发布**到Kubernetes ApiServer中。

##### Spec是怎么变成一个运行的容器的

当ApiServer处理应用程序的Spec时，**调度器将指定的容器调度到可用的工作节点上**（调度基于所需的资源以及工作节点未分配的资源），然后工作节点上的**kubelet调用容器运行时（Docker、rkt）拉取所需的镜像并运行容器**。

##### 保持容器运行

一旦应用程序运行起来，Kubernetes就会**不断地确认应用程序的部署状态始终与Spec中的要求相匹配**。如果节点故障或者程序故障，Kubernetes将会为故障的节点或者应用程序重新选择节点，并在新节点上运行它们。

##### 扩展副本数量

当应用程序运行时，可以决定要增加或减少副本量，Kubernetes将分别运行额外的容器或停止多余的容器。甚至可以**将决定最佳副本数量的工作交给Kubernetes**（将根据实时指标如CPU负载、内存消耗、每秒查询量、应用程序公开的其他指标）自动调整副本数。

##### 访问移动的容器

Kubernetes**通过一个静态IP地址指向特定的服务**，并将其暴露给集群中运行的所有应用程序。

#### Kubernetes的好处

如果在所有服务器上部署了Kubernetes，那么**运维团队就不需要再部署应用程序**了，**系统管理员不需要安装任何东西来部署和运行应用程序**。在任何部署了Kubernetes的节点上，**Kubernetes可以在不需要系统管理员任何帮助的情况下立即运行应用程序**。

##### 简化程序部署

由于Kubernetes将整个数据中心作为单个操作平台，应用程序开发人员可以自行部署应用程序，而不需要了解组成集群的服务器。

##### 更好的利用硬件

通过在服务器上装配Kubernetes，并使用它运行应用程序而不是手动运行它们，这表示着我们**已经应用程序与基础设施分离开来**。在集群上运行的不同应用程序可以被移动和匹配来确保节点的硬件资源得到尽可能好的利用。

Kubernetes可以更好的利用基础设施，由于是当服务器或者应用程序的数量都很大的时候，机器可以比人类更好、更快地完成这项工作。

##### 健康检查和自修复

Kubernetes监控应用程序组件和它所在的节点，并在节点出现故障时自动将他们重新调度到其他节点上。这使得运维人员不需要手动迁移应用程序组件，更加专注于修复节点本身将其送回到可用的硬件资源池中。

##### 自动扩容

使用Kubernetes来管理部署的程序，也意味着运维团队不需要不断监控单个应用程序的负载来应对负载峰值。

### 小结

* 单体应用程序更容易部署，但随着时间推移更难维护，并且难以扩展
* 基于微服务的应用程序使每个组件的开发更容易，但是很难配置和部署它们作为一个整体进行工作
* Linux容器提供的好处和虚拟机差不多，但它们**轻量**许多，并且允许更好地利用硬件
* 通过更简单快捷地将容器化应用和其操作系统一起管理，Docker改进了现有的Linux容器技术
* Kubernetes将整个数据中心暴露为用于允许应用程序的单个计算资源
* 开发人员可以通过Kubernetes部署应用程序，而无需系统管理员和运维的帮助

