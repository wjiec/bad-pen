Kubernetes介绍
-----------------------

如今，大型单体应用正被逐渐分解成小的、可独立运行的组件（我们称之为**微服务**）。微服务彼此之间解耦，所以它们可以被独立开发、部署、升级、伸缩。这使得我们可以对每一个微服务实现快速迭代，并且迭代的速度可以和市场需求的变化相匹配。

随着部署组件的增加和数据中心的增长，配置和管理并保持系统的正常运行变得越来越困难。我们想降低硬件成本并获得足够高的资源利用率正变得越来越困难。

而这正是Kubernetes在做的，Kubernetes可以进行自动化的调度、配置、监管和故障处理。Kubernetes使开发者能完全脱离运维团队的帮助自主部署应用，并且控制部署的频率。而运维团队可以通过Kubernetes监控整个系统，并且在硬件故障时重新调度应用。

Kubernetes通过对实际硬件做抽象，然后将自身暴露成一个平台用于部署和运行应用程序。它允许开发者自己配置和部署应用程序，而不需要系统管理员的任何帮助。让系统管理员聚焦于保持底层基础设施运转正常的同时，不需要关注实际运行在平台的应用程序。

### Kubernetes系统的需求

Kubernetes一方面需要适应因为应用部署的变化而出现的环境需求的差异，另一方面是需要适应应用的基础架构（环境和依赖）的变化。

#### 应用开发部署的变化

对于单体应用来说，即使是某个组件中小的修改，都需要重新部署整个应用。组件之间缺乏严格的边界定义，组件之间相互依赖。日积月累下来导致系统复杂度提升，整体质量也急剧恶化。

这些问题迫使我们将复杂的大型单体应用拆分为小的可独立部署的微服务组件。每个微服务以独立的进程运行，并通过**简单且定义良好**的接口与其他服务通信。

##### 单体应用和微服务应用的扩容对比

因为每个微服务都是独立的进程，只要API不变或者保持向前兼容，那么我们并不需要对其他微服务进行改动或者重新部署。

面向单体系统，扩容针对的是整个系统。而对于微服务架构，扩容只需要针对单个服务，这意味着我们可以选择性的扩容需要更多资源微服务，而其他微服务了仍然保持原样。

##### 部署微服务

微服务在组件数量增多的时候，也暴露了一些缺点，部署相关的决定会变得越来越困难（应用的组合变多，应用间依赖的组合更以几何倍数变多）。

##### 环境需求的差异

因为微服务架构中的组件不仅是独立部署，也是在独立开发。正是因为这种独立性，不同的组件使用不同的环境和依赖是非常常见的事情。在生产服务器部署并管理这种应用简直就是运维的噩梦。

#### 为应用程序提供一个一致的环境

开发和运维团队需要解决的最大的一个问题是程序运行环境的差异性，这种差异性存在于从硬件到操作系统再到没太机器的动态链接库上。为了解决这个问题，最理想的做法是让应用在开发和生产环境运行在完全一样的环境下（一样的操作系统、动态库、系统配置、网络环境和其他所有的条件）。

#### 持续交付：DevOps

让一个团队参与应用的开发、部署、运维的整个生命周期可以让开发者、QA和运维团队彼此之间的合作贯穿整个流程。这种实践被称为DevOps。

##### 带来的优点

这种实践可以让开发者更多地在生产环境中运行应用，并更多的理解用户的需求和问题，以及运维团队维护应用所面临的困难。

##### 让开发者和系统管理员做他们最擅长的

让开发者创造性的功能和提升用户体验，让运维团队负责管理生产部署流程以及应用所在的硬件设备。

### 容器技术

Kubernetes使用Linux容器技术来隔离应用，通过熟悉容器的基本知识来更加深入地理解Kubernetes，包括认识到存在得容器技术分支（例如Docker或者rkt）。

#### 什么是容器

当一个应用程序的组件开始变小且数量开始增长时，如果不想因为创建过多的虚拟机浪费硬件资源，又想持续压低硬件成本，那就不能给每个组件配置一个虚拟机了。而这不仅仅是浪费硬件资源的问题，因为每个虚拟机需要背单独配置和管理，所以增加虚拟机的数量也会带来人力资源的浪费。

##### 用Linux容器技术隔离组件

容器允许在一台机器上运行多个服务，不仅为不同的服务提供不同的环境，同时也会将这些服务相互隔离。**容器类似于虚拟机，但是开销小得多**。

**容器中运行的进程实际上运行在宿主机的操作系统上**，就像所有其他进程一样（虚拟机中的进程是运行在不同操作系统上的），但是容器中的进程是和其他进程隔离的。

##### 比较虚拟机和容器

与虚拟机相比，**容器更加轻量化**（它允许在相同的硬件上运行更多的服务）。虚拟机需要运行自己的一组系统进程，这些系统进程就会产生额外的计算资源消耗，而多个容器则会完全在宿主机的内核上运行。

虚拟机的主要好处是他们提供**完全隔离的环境**，因为每个虚拟机都运行在它自己的内核上，而**容器都是调用的同一个内核**（这也会带来一定的安全隐患）。

##### 容器实现隔离的机制

容器实现隔离主要依赖于以下2个功能：

* Linux的**命名空间**：它使每个进程只能看到它自己所在的命名空间的系统资源（文件、进程、网络接口、主机名等）
* Linux**控制组**（cgroup）：它限制了进程能使用的资源量（CPU、内存、网络带宽等）

##### 命名空间隔离的系统资源

运行在某个命名空间中的进程将只能看到同一个命名空间下的资源。系统存在多个类型的多个命名空间，所以**进程不单单只属于某一个命名空间，而是属于每个类型下的某一个命名空间**。存在以下类型的命名空间：

* Mount（mnt）
* Process ID（pid）
* Network（net）
* Inter-Process Communication（ipc）
* UTS（hostname、domain）
* User ID（user）

以上每种命名空间被用来隔离一组特定的资源。

##### 限制进程的可用资源

cgroup是一个Linux内核功能，它被用来**限制一个进程或者一组进程的资源使用**，这种限制使得进程不能过分使用为其他进程保留的资源。

#### Docker容器平台介绍

**Docker是第一个使容器能在不同机器之间移植的系统**，容器技术也是因为Docker的出现而变得广为人知。

基于Docker容器的镜像和虚拟机的镜像一个很大的不同是**容器镜像是多层结构**的，每个层能在多个镜像之间共享。

##### Docker的概念

**Docker是一个打包、分发和运行应用程序的平台**，它允许你将应用程序和应用程序所依赖的整个环境打包在一起，并且Docker通过中央仓库使得这个包可以被分发到任何运行Docker的机器上并被执行。而这依赖于一下三个主要概念：

* 镜像：Docker镜像里包含了打包的应用程序及其所依赖的环境
* 镜像仓库：用于存放Docker镜像，促进不同人和不同电脑之间共享这些镜像
* 容器：基于Docker镜像创建的Linux容器，在其中运行的应用程序与宿主机上的其他镜像相互隔离并且资源受限

##### 镜像层（Layer）

**不同镜像可能包含完全相同的层**，因为这些镜像可能都是在另一个镜像之上构建的（不同的镜像都能使用相同的父镜像作为它们的基础镜像）

**镜像层不仅使分发变得更加高效，也有助于减少镜像的存储空间**（相同的层会被共享，镜像层是只读的）。

##### 容器镜像移植上的限制

如果一个容器化的应用需要一个特定的内核版本，那它可能就会有移植上的问题（不能在所有机器上都正常工作）。而不仅仅是内核的问题，在一个特定硬件架构（amd64、arm）之上编译出来的容器应用只能在相同架构的机器上运行。

#### rkt（一个Docker的替代方案）

和Docker一样，rkt也是一个运行容器的平台，它更强调安全性、可构建性，并遵从容器开放标准（OCI）。

**不应该错误的认为Kubernetes只是一个专门为Docker容器设计的容器编排系统。实际上Kubernetes的核心远不止是容器编排**
