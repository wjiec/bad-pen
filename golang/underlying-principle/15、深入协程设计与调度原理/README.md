深入协程设计与调度原理
-----------------------------------

Go 语言轻量级的协程借助运行时的调度。



### 协程的生命周期与状态转移

协程并不只有创建和死亡两种状态，为了便于对协程进行管理，Go 语言的调度器将协程分为多种状态。

![Go 语言调度器与Goroutine 实现原理| Go 语言设计与实现](./goroutine-states.png)

Copyright: Go 语言调度器与Goroutine 实现原理| Go 语言设计与实现

* Gidle 为协程刚创建时的状态，当新创建的协程初始化后，会变为 Gdead 状态，这个状态同时也是协程被销毁时的状态
* Grunnable 表示当前协程在运行队列中，正在正待运行
* Grunning 代表当前协程正在运行中，已经分配给逻辑处理器和逻辑线程
* Gwaiting 表示当前协程在运行时被锁定，不能执行用户代码。在垃圾回收以及 channel 通信时经常会遇到这种情况
* Gsyscall 表示当前协程正在执行系统调用
* Gcopystack 表示当前协程在进行栈扫描时发现需要扩容或缩小栈，将协程中的栈转移到新栈时的状态



### 特殊协程 g0 与协程切换

在 Go 程序中，main 协程只有一个，而**每个线程**上都会有一个特殊的协程 g0。这个协程运行在操作系统栈上，其作用是执行协程调度的一系列运行时代码，一般的协程无差别地用于执行用户代码。

在用户协程退出或者被抢占时，意味着需要重新执行协程调度，这时需要从用户协程 g 切换到协程 g0。

当某一个协程 g 执行上下文切换时需要保存当前协程的执行现场，才能够在后续切换回 g 协程时正常执行。协程的执行现场存储在 g.gobuf 结构体中，g.gobuf 结构体主要保存 CPU 中几个重要的寄存器值，分别是 rsp，rip，rbp（为什么不需要保存 rax， rbx 等寄存器？）。



### 线程本地存储与线程绑定

线程本地存储是一种计算机编程方法，它使用线程本地的静态或全局内存。线程本地存储中的便利只对当前线程可见，一般地，操作系统使用 FS / GS 段寄存器存储线程本地变量。

在 Go 语言运行时的调度器中使用线程本地存储将具体操作系统线程与运行时代表线程的 m 结构体绑定在一起。**线程本地存储的实际是结构体 m 中 m.tls 的地址**，**同时 m.tls[0] 会存储当前线程正在运行的协程 g 的地址**。因此在任意一个线程内部，通过线程本地存储，都可以在任意时刻获取绑定到当前线程上的协程 g，结构体 m，逻辑处理器 p，特殊协程 g0 等信息。



### 调度循环

