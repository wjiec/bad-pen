调试利器：特征分析与事件追踪
--------------------------------------------

Go 语言中的 pprof 指对于指标或特征的分析（Profiling），通过分析不仅可以查找到程序中的错误（内存泄露、race冲突、协程泄露），也能对程序进行优化（例如CPU利用率不足）



### pprof 的使用方式

在通过 pprof 进行特征分析时，需要执行两个步骤：收集样本和分析样本。

收集样本由两种方式：一种是引用 `net/http/pprof` 并在程序中开启 http 服务。另一种方式是直接在代码中需要分析的位置嵌入分析函数。

最常用的 4 种 pprof 类型包括了堆分析 heap、协程栈分析 goroutine、CPU 占用分析 profile，程序运行跟踪信息 trace。

#### 堆内存特征分析

`top` 命令会列出以 flat 列从大到小排序的列表。其中 flat 代表当前函数统计的值，cum 是一个累积的概念，指当前及其调用的函数 flat 的和。

`top -cum` 可以根据 cum 进行排序。

`list func-name` 可以列出函数的信息。

`tree` 命令用于打印函数的调用链，能够得到函数调用的堆栈信息。

`web` 命令可以通过 `graphviz` 通过可视化的方式显示结果。

#### 协程栈分析

协程分析一可以查看协程的数量，查看协程是否泄漏，二是查看当前大量的协程正在执行哪些函数，判断当前协程是否健康。

#### base 基准分析

pprof 还提供更强大的工具用于对比前后特征文件的不同。可以使用 `-base` 参数后跟基准特征文件，来对比两个特征文件之间的差异。

#### CPU 占用分析

在实践中经常使用 pprof 分析 CPU 占用，它提供了强有力的工具，在不破坏原始程序的情况下，估计出函数的执行时间，从而找出程序的瓶颈。

```shell
go tool pprof http://localhost:8088/debug/pprof/profile?seconds=30
```

对 CPU 的分析需要一定的时间，参数中的 `seconds` 参数用于指定花费多少时间来收集特征信息。



### 火焰图分析

火焰图可以快速准确地识别出最频繁使用的代码路径，从而得知程序的瓶颈所在。我们可以简单地通过 pprof 工具查看火焰图：

```shell
go tool pprof -http :8081 http://localhost:8088/debug/pprof/profile?seconds=30
```

这边是将开启内置的 http 服务器，`:8081` 表示监听的 IP 和端口。可以在 View 中选择查看 `Flame Graph`。

其中函数调用栈越长，火焰就越高。框越长、颜色越深、代表当前函数占用 CPU 时间越久。



### Trace 事件追踪

trace 工具可以提供指定时间内程序发生的事件的完整信息，这些信息包括：

* 协程的创建、开始和结束
* 协程的阻塞——系统调用、通道、锁
* 网络 IO 相关事件
* 系统调用事件
* 垃圾回收相关事件

收集 trace 文件有两种方式：一是在程序中使用 `runtime/trace` 包的接口，二是使用 http 服务的 `/debug/pprof/trace` 端点来下载 trace 文件。

要对获取的文件进行分析时，需要使用 trace 工具：`go tool trace trace.out`

trace 工具飞车强大，提供了追踪到的运行时的完整事件和宏观视野。



### pprof 底层原理

pprof 分为采样和分析两个阶段。



#### 堆内存样本

对堆内存采样时，并不是每次调用 mallocgc 分配堆内存都会被记录下来，这里有一个指标 `MemProfileRate` 当多次内存分配累积到该指标上时，才会记录一次。

#### 协程栈样本

协程栈关注的是当前有多少协程以及大部分协程正在执行什么函数。所以每次获取协程栈样本都需要启动 STW。

#### CPU 样本

这需要借助程序终端的功能为分析和调试提供时机，在类 UNIX 系统中，会通过调用操作系统库函数 `setitimer` 来实现。`setitimer` 将按照设定好的频率中断当前程序，并进入操作系统内核处理中断事件。 

当调用 pprof 获取 CPU 样本时，程序会为 `setitimer` 函数设置中断频率为 100Hz，即每秒中断100次。



### trace 底层原理

trace 提供了强大的内省功能，但是这种功能不是没有代价的，Go 语言在源码中每个重要的事件处都加入了 `trace.enabled` 是否开启的判断，并编译到了程序中，当 trace 开启时，会触发 `traceEvent` 写入事件。
