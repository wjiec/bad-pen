内存分配管理
-------------------

Go 语言与现实依靠细微的对象切割、极致的多级缓存、精准的位图管理实现了对内存的精细化管理。



### Go 语言内存分配全局视图

Go 语言将内存分为了大大小小 67 个级别的 span，其中 0 级代表特殊的大对象，其大小是不固定的。当具体的对象需要分配内存时，并不是直接分配 span，而是分配不同级别的 span 中的元素。



#### 三级对象管理

为了能够方便地对 span 进行管理，加速 span 对象的访问和分配，Go 语言采取了三级管理结构，分别为 mcache、mcentral、mheap。

* mspan：每个逻辑处理器 P 都存储了一个本地 span 缓存，称作 mcache。除 class0 之外，mcache 中的 span 都来自 mcentral。
* mcentral：被所有逻辑处理器 P 共享，每个级别的 span 都会有一个 mcentral 来管理，每个 mcentral 中都包含两个 mspan 的链表
  * empty：表示没有空闲对象或已经被 mcache 缓存的 span 链表
  * nonempty：表示有空闲对象的 span 链表
* mheap：主要用于管理 mcentral，同时负责大对象的分配

堆区的内存被分成了 HeadArena 大小进行管理，对 Heap 进行的操作必须全局加锁，而 mcache、mcentral 可以被看做是某种形式的缓存。

#### 四种内存块管理

根据对象的大小，Go 语言将堆区分成了 HeapArena、chunk、span 和 page 进行管理。



### 对象分配

Go 语言将小于 16 字节的对象划分为微小对象，在 16 字节到 32k 字节的对象分为小对象，大于 32k 的则为大对象。

对象分配过程中主要经历以下几个过程：

* 查找对应对象大小的 span，检查是否能在其中进行分配内存
* 如果当前要分配的元素空间不足，将尝试从 mcache 中查找 span 中的下一个可用的元素。
  * 通过位图标记 span 中的元素是否被分配
* 如果当前 span 中没有可以使用的元素，就需要从 mcentral 中加锁查找
  * 需要同时从 empty 和 nonempty 链表中进行查找
* 如果在 mcentral 中找不到可以使用的 span，就需要在 mheap 中查找。
  * 在 mheap 中管理线性地址空间的位图结构叫做基数树
* 当在 mheap 中也找不到可用的连续内存时，就需要从操作系统中获取内存
  * 每次从操作系统申请的内存必须是 HeapArena 的整数倍

