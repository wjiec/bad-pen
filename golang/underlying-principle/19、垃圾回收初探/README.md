垃圾回收初探
-------------------

垃圾回收作为内存管理的一部分，包含三个重要的功能：分配和管理新对象、识别正在使用的对象、清除不再使用的对象。具有垃圾回收功能的语言屏蔽了内存管理的复杂性，开发者可以更好地关注核心的业务逻辑。



### 垃圾回收的5种经典算法



#### 标记 - 清除

标记 - 清除（Mark - Sweep）算法分为两个主要阶段，第一阶段是扫描并标记当前活着的对象，第二阶段是清扫没有标记的垃圾对象。因此，标记 - 清除算法是一种间接的垃圾回收算法，它不直接查找垃圾对象，而是通过活着的对象推断出垃圾对象。

由 Dijkstra 提出的三色标记算法：通过将对象标记为黑色（已经被扫描）、灰色（暂时还没有被扫描，扫描之后会转换为黑色）、白色（暂时还没有被扫描，可能有垃圾对象，如果被灰色对象扫描引用并扫描到，则会标记为灰色）来对对象进行区分。

标记 - 清除算法的主要缺点在于可能产生内存碎片或空洞，这会导致更新对象分配失败。

#### 标记 - 压缩

标记 - 压缩（Mark - Compact）算法通过将分数的、活着的对象移动到更紧密的空间来解决内存碎片问题。其缺点在于内存对象在内存的位置是随机的，这常常会破坏缓存的局部性。

#### 半空间复制

半空间复制（Semispace Copy）是一种用空间换时间的算法。经典的半空间复制算法只能使用一半的内存空间，保留另一半的内存空间用于快速压缩内存。

半空间复制在扫描根对象时就可以直接压缩，每个扫描到的对象都会从其中一半空间转移到另一半空间中。因此，一旦扫描完成，就得到了一个压缩后的副本。

> Java 中的年轻代、老年代内存模型，其中年轻代中有两个空间，相互倒腾数据可能就是借鉴了半空间复制的思想。

#### 引用计数

一种直接简单的识别垃圾对象的算法是引用计数（Reference Counting）。每个对象都包含一个引用计数，每当其他对象引用了此对象时，引用计数都会增加。反之，取消引用之后，引用计数就会减少。一旦引用计数为0，就表明该对象为垃圾对象，需要被回收。

引用计数的致命缺点：一些没有破坏性的操作（只读操作、循环迭代、栈上引用）更新引用计数的代价（原子操作带来的额外CPU周期）是难以接受的

#### 分代GC

分代GC指将对象按照存活时间进行划分。这种算法重要前提是：释放的对象一般都是新创建不久的，因此，没有必要反复地扫描旧对象，这大概率会加快垃圾会受到额速度，图稿处理能力和吞吐量，减少程序暂停的时间。



### Go 语言中的垃圾回收

Go 语言采用了并发三色标记算法进行垃圾回收。同时由于使用了现代内存分配算法 tcmalloc 虽然没有压缩算法那样极致，但它已经很好地解决了内存碎片的问题。不选择分代 GC 是由于编译器的优化，Go 语言通过内存逃逸的机制将会继续使用的对象转移到堆中，大部分生命周期很短的对象会在栈中分配，这和其他使用分代 GC 的变成语言有显著的不同，减弱了分代 GC 的优势。



#### Go 垃圾回收演进

Go 1.0 中仅支持单协程的垃圾回收，在垃圾回收开始阶段需要停止所有用户协程，并且垃圾回收阶段只有一个协程在进行垃圾回收。

Go 1.1 之后，垃圾回收由多个协程并行执行，大大加快了垃圾回收的速度，但是这阶段仍不允许用户协程执行。

Go 1.5 对垃圾回收进行重大更新，该版本允许用户协程与后台的垃圾回收同时执行，大大降低了用户协程暂停的时间（300ms -> 40ms）

Go 1.5 大幅度降低了在 STW 期间的任务，使得用户协程暂停的时间从 40ms 左右降低到 5ms 左右。

Go 1.8 使用了混合写屏障消除了栈重新扫描的时间，将用户协程暂停的时间降低到 0.5ms 左右。