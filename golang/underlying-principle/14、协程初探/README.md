协程初探
-------------

Go 语言通过更轻量级的协程让开发更加便捷，同时避免了许多传统多线程开发需要面对的困难。



### 进程与线程

在计算机科学中，线程是可以由调度程序（通常是操作系统的一部分）独立管理的最小程序指令集，而进程是程序运行的实例。在大多数情况下，线程是进程的组成部分。一个进程中可以存在多个线程，这些线程并发执行并共享进程的内存（例如全局变量）等资源。而进程之间相对独立，不同进程具有不同的内存地址空间、代表程序运行的机器码、进程状态、操作系统资源描述符等。

操作系统调度到 CPU 的执行的最小单位是线程。在多核 CPU 上，线程可以分布在多个 CPU 核心上，从而实现真正的并行处理。



### 线程上下文切换

为了平衡每个线程能够被 CPU 处理的时间并最大化利用 CPU 资源，操作系统需要在适当的时间通过定时器终端（Timer Interrupt）、I/O 设备中断、系统调用执行上下文切换（Context Switch）。当发生线程上下文切换时，需要从操作系统用户态转移到内核态，并记录上一个线程的寄存器、进程状态等信息。

当切换到下一个要执行的线程时，需要加载寄存器的值，并从内核态转移到用户态。如果线程在上下文切换时属于不同的进程，那么需要更新额外的状态信息及内存地址空间，同时将页表（Page Tables）导入内存。

进程之间的上下文切换最大的问题在于你村地址空间的切换导致的缓存失效（例如 CPU 中用于缓存虚拟地址和物理地址之间映射的 TLB 表），所以在不同进程的切换要显著慢于同一进程中线程的切换。



### 线程与协程

协程被认为是轻量级的线程。和线程不同的是，操作系统内核感知不到协程的存在，协程的管理依赖 Go 语言运行时自身提供的调度器。



#### 调度方式

协程是用户态的，协程的管理依赖 Go 语言运行时的调度器。



#### 上下文切换的速度

协程的速度要快于线程，原因在于协程切换不用经过操作系统用户态与内核态的切换，并且 Go 语言中的协程切换只需要保留极少的状态和寄存器变量值（SP / BP / PC），而线程切换回保留额外的寄存器变量值（例如浮点寄存器）。



#### 调度策略

线程的调度在大部分时间是抢占式的，系统调度器为了均衡每个线程的执行周期，会定时发出中断型号强制执行线程上下文切换。而协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动地切换上下文。



#### 栈的大小

线程的栈大小一般是在创建时指定，为了避免出现栈溢出（Stack Overflow），默认的栈会相对较大（例如 2 MiB），而 Go 语言中的协程默认为 2KiB ，在实践中，经常会看到成千上万的协程存在。

同时，现场的栈在运行时不能更改，而 Go 语言中的协程栈在运行时的帮助下会动态监测栈的大小，并动态的进行扩容。



### 并发与并行

并发（Concurrency）与并行（Parallelism）是两个非常重要但是非常容易混淆的概念。所谓并发，指的是在**一个时间段**内，所有任务都能获得执行的机会且能完成。而并行指的是在**同一个时刻**有多个任务在同时运行。



### GMP 模型

在 GMP 模型中，G 代表的是 Go 语言中的协程（Goroutine），M 表示实际执行的线程，而 P 代表的是 Go 逻辑处理器。在任意时刻总有以下特性：

* 在任意时刻，一个 P 中可能在其本地包含多个 G
* 一个 P 在任一时刻只能绑定一个 M
* 一个 G 并不是固定绑定在一个 P 上的，有很多情况会导致一个 P 中的 G 转移到其他的 P 上
* 一个 P 只能对应一个 M，但是具体是哪个 M 也是不固定的，一个 M 可能在某些时候转移到其他的 P 中执行
