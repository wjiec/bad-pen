内存管理
---

内存管理是运行时的另一部分，主要负责应用程序如何申请、分配和回收内存，尤其是栈上和堆中的内存都是如何被管理和分配的。



### 内存分配器

内存空间包含两个重要区域：栈区和堆区。函数调用的参数、返回值以及局部变量大都会被分配到栈上，**由编译器负责管理**。堆中的对象**由内存分配器分配并由垃圾收集器回收**。

#### 分配原理

Go 语言的内存分配器借鉴 TCMalloc 的设计实现高速内存分配，其核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。

内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同等级分别管理。内存分配器引入线程缓存（thread cache）、中心缓存（central cache）和堆（heap）3 个组件分级管理内存。

#### 稀疏内存

使用稀疏内存布局不仅能移除堆大小的上限，还能解决 C 语言和 Go 语言混合使用时的地址空间冲突问题。不过基于稀疏内存的内存管理失去了内存连续性这一假设，使得内存管理变得更加复杂。

#### 内存管理组件

内存管理中有几个重要的组件：`runtime.mspan`、`runtime.mcache`、`runtime.mcentral`、`runtime.mheap`。

##### mspan

mspan 是 Go 语言内存管理的基本单元，该类型是一个双向链表实现。每个 mspan 都管理 npages 个页（8kb 大小），当结构体管理的内存不足时，运行时会以页为单位向堆申请内存。

##### mcache

mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。在 mcache 中还包含了用于分配微小对象的分配器，专门管理 16 字节以下的对象。

##### mcentral

Mecntral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁。

##### mheap

mheap 是内存分配的核心数据结构，Go 语言程序会将其作为全局变量存储，堆中初始化的所有对象都是由该结构体统一管理的。

#### 内存分配

堆中多有对象都会通过调用 `runtime.newobject` 函数分配内存，该函数会调用 `runtime.mallocgc` 分配指定大小的内存空间。

对于微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，主要用来分配较小的字符串以及逃逸的临时变量。**微分配器管理的对象不可以是指针类型。**

小对象是指大小在 16 到 32768 字节的对象，以及所有小于 16 字节的指针类型的对象。

大对象会单独处理大于 32KB 的对象，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用 `runtime.mcache.allocLarge` 分配大块内存。



### 垃圾收集器

标记清除算法是最常见的垃圾收集算法，其执行过程分为标记和清除两个阶段：

* 标记阶段——从根对象出发查找并标记堆中所有存活的对象
* 清除阶段——遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表

#### 三色抽象

为了解决原始标记清除算法带来的长时间 STW 问题，多数现代追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 时间。当三色标记清除算法的标记阶段结束之后，应用程序的堆中就不存在任何灰色对象了，我们只能看到黑色的存活对象以及白色的垃圾对象，此时垃圾收集器就可以回收这些白色的垃圾了。

##### 屏障技术

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定约束。垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，可以分为读屏障和写屏障。

##### 三色不变性（Tri-color invariant）

* 强三色不变性——黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象
* 弱三色不变性——黑色对象指向的白色对象必须包含一条从灰色对象经过多个白色对象的可达路径

##### Dijkstra

通过插入写屏障，可以在每当执行类似 *slot = ptr 的表达式时，我们会通过写屏障尝试改变指针的颜色，如果 ptr 指针是垃圾，那么写屏障会将该对象设置成灰色（待扫描），其他情况则保持不变。

Dijkstra 的插入屏障是一种相对保守的屏障策略，它会将**有存活可能的对象都标记为灰色**以满足强三色不变。虽然插入写屏障实现简单并且能保证强三色不变性，但是为了保证内存安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段重新扫描栈上的对象。

##### 删除写屏障

Yuasa 提到的删除写屏障会在老对象的引用被删除时，将白色的（垃圾）老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。

##### 增量垃圾回收

增量地标记和清除垃圾，降低应用程序暂停的时间。使用屏障技术保证垃圾收集的正确性。增量垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象的强三色不变性或弱三色不变性。

##### 并发垃圾回收

利用多核的计算资源，在用户程序执行时并发标记和清除垃圾。**使用屏障技术保证垃圾收集的正确性**。

##### 实现原理

Go 语言的垃圾收集可以分成清除、清除终止、标记、标记终止和清除 5 个阶段。触发时机会通过 `runtime.gcTrigger.test()` 方法决定是否需要触发垃圾收集。
