接口
------

在Go语言中，接口是一个编程规约，也是一组方法签名（函数字面量类型，不包括函数名）的集合。一个具体类型的方法集是接口方法集的超级，就代表类型实现了这个接口（不需要在语法上进行显式的声明）。**编译器会在编译时进行方法集的校验**。

最常使用的接口字面量类型是空接口（`interface{}`），由于空接口的方法集为空，所以任何类型都可以被认为实现了空接口。任意类型的实例都可以赋值或传递给空接口，包括未命名类型。



### 基本概念

接下来主要介绍

#### 接口声明

Go语言中接口分为接口字面量和接口命名类型，接口的声明使用`interface`关键字

```go
// 接口字面量
interface {
    Write([]byte) (int, error)
}

// 接口字面量的使用
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    _, _ = w.(interface {
        Write([]byte) (int, error)
    })
})

var r interface {
    Read(p []byte) (int, error)
}
r = os.Stdin

// 空接口也是一个接口字面量
interface{}

// 接口命名类型
type InterfaceName interface {
    FunctionSignature()
}

// 也可以嵌入另一个接口类型
type EmbeddedInterface interface {
    io.Reader
    io.Writer
}
```

**Go编译器在做接口匹配判断时时严格校验方法名称和方法签名（方法字面量，不包括方法名）的**。

#### 接口初始化

接口只有在初始化为具体的类型时才有意义。没有初始化的接口变量，其默认值是nil。接口绑定具体类型的实例的过程被称为接口初始化，有以下两种方式

1、将实例赋值给接口变量

如果某个具体类型的方法集是某个接口方法集的超集，那我们就可以将该类型的实例直接赋值给接口类型的变量，**此时编译器会进行静态的类型检查**。接口在被初始化之后，**调用接口的方法就相当于调用接口绑定的具体类型的方法**。

2、将已初始化的接口赋值给另一个接口

如果B接口的方法集是A接口方法集的子集，那么我们可以将已初始化的A接口类型变量a直接赋值给B接口类型变量b，此时编译器会在编译时进行方法集的静态检查。这种情况下**接口变量b的具体实例是接口变量a绑定的具体实例的副本**。

```go
type Apple interface {
	App()
}

type Banana interface {
	Apple

	Ban()
}

type Sample struct{}

func (Sample) App() {}
func (Sample) Ban() {}

func main() {
    // 这个例子不好，没想到啥好的解释方法
	s := Sample{}
	fmt.Printf("&s = %p\n\n", &s)

	var b Banana = s
	fmt.Printf("&s = %p\n", &s)
	fmt.Printf("&b = %p\n\n", &b)

	var a Apple = b
	fmt.Printf("&s = %p\n", &s)
	fmt.Printf("&b = %p\n", &b)
	fmt.Printf("&a = %p\n\n", &a)
}
```

#### 调用接口方法

接口方法调用的最终地址是在运行前决定的，**将具体类型变量赋值给接口之后，会使用具体类型的方法指针初始化接口变量**。当调用接口方法时，实际上是间接地调用实例的方法（**有一定的运行时开销**）。

#### 接口的动态类型和静态类型

接口的动态类型：接口**绑定的具体实例的类型**成为接口的动态类型（接口的动态类型随着其绑定的具体实例类型而变化）。

接口的静态类型：接口被定义时的类型被称为接口的静态类型，静态类型的本质特征就是接口的方法签名集合（方法集）。

**如果两个类型的方法签名（不带名字的方法字面量）集合相同（顺序可以不一样），他们之间就不需要强制类型转换就可以相互赋值。原因是Go编译器校验接口是否能赋值比较的是二者的方法集，而不是看具体接口类型名。**



### 接口运算

为了知道已经初始化的接口变量绑定的具体类型，以及这个具体实例是否还实现了其他接口。Go语言提供两种语法结构来支持这两种需求，分别是**类型断言**和**类型接口查询**。

#### 类型断言（Type Assertion）

类型断言的基本语法形式如下：

```go
i.(TypeName) // i 必须是接口变量，否则编译器会报错
```

接口断言的两层含义：

1、如果`TypeName`是一个具体类型名，则类型断言用于判断接口变量 `i` 绑定的实例类型是否就是具体类型 `TypeName`

2、如果`TypeName`是一个接口类型名，则类型断言用于判断接口变量 `i` 绑定的实例类型是否实现了`TypeName`接口

##### 接口断言的复制形式

```go
// 如果成功断言，则 v 是接口绑定类型实例的副本（断言类型）或是底层绑定具体类型实例的副本的接口变量（断言接口）
// 如果断言失败，则直接 panic
v := i.(TypeName)

// 如果成功断言，则 v 是接口绑定类型实例的副本（断言类型）或是底层绑定具体类型实例的副本的接口变量（断言接口）且 ok = true
// 如果断言失败，不会发生 panic，且 ok = false 同时 v 为 TypeName 类型的零值（断言类型则是具体类型的零值，断言接口则是 nil）
v, ok := i.(TypeName)
```

#### 类型查询（Type Switches）
